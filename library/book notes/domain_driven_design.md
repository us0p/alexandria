Is a way o f thinking and a set of priorities, aimed at accelerating software projects that have to deal with complicated domains.
premise:
- for most software projects, the primary focus should be on the domain and domain logic.
- complex domain designs should be based on a model.
it's oriented toward Agile Development Processes. It assumes a couple of process practices:
- Iterative development.
- A close relationship between developers and domain experts. DDD crunches knowledge into a model that reflects deep insight into the domain and a focus on the key concepts. This is a collaboration between those who know the domain and those who know how to build software. This collaboration must continue throughout the project's life.
>Valuable models do not emerge immediately. They require a deep understanding of the domain. Which comes from diving in, implementing an initial design based on a probably naive model, and then transforming it again and again.

Every model represents some aspect of reality. It is a simplification. It's an interpretation of reality that abstracts the aspects relevant to solving the problem at hand and ignores extra details.

Every software program relates to some activity or interest of its user. That subject area to which the user applies the program is the "domain" of the software.

To create  valuable software, we must bring a to bear a body of knowledge related to the activities the software will be involved in. The amount of knowledge can be overwhelming. This is when a team can use modeling to wrestle with that overload.

Domain modeling is not a matter of making as "realistic" a model as possible. Nor is it just the construction of a software mechanism that gives the necessary results. It is more like movie making, loosely representing reality to a particular purpose. Just as a moviemaker selects aspects of experience and presents them in an idiosyncratic way to tell a story or make a point, a domain model is chosen for its utility.