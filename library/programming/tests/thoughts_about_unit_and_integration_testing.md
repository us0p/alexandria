- you should only unit test business rules
- split your code to separate rules from external systems to avoid mocking in excess.
- avoid testing things you don't know the expected behavior, or what it should do, tests can be used to drive the design and implementation of something that you know the behavior.
- it's a good call to unit test complex problems or things that are too hard to test manually. using tests to drive correctness of complex problems and to automate complex manual testing can save a lot of time.
- when you're working in a distributed architecture, running integration or e2e tests can become a very complicated thing as you need all the other services to be in the same stage as your code as well (dev, staging, etc).
- some people prefer to write tests before the prototype phase, when code has begun to firm up.
- unit tests tend to break as implementation change and make refactor hard. doesn't catch bugs of interactions with other code. often throw away when code change.
- unit tests are tests that provide value in the short time but can become a debt as the projects lives on.
- e2e tests provide a overall understanding of the system and provide more value in the long time but can be hard to understand and can become a clumsy test that is often ignored.
- integration tests is a high level testing of the system that doesn't test a complete segment of the system, it just tests the integration of the components. It can test the correctness of the system with access to low level details and is easy to see what break.
- integration tests is better done when system start to stabilize.
- integration tests remain valuable for many time.
- should focus e2e tests on most common and important features and edge cases, but not too many or they become impossible to maintain and then possibly ignored.
- tdd is specially good for regression tests, when you find a bug, you first write the test that reproduces the bug and then fixes it.
- The best tests are the ones that are deeply on the context of the problem that they are testing.
- tests makes much less likely that you're going to change the code that's underneath them. which is probably bad because most code should eventually change.
- if something is fragile and you write tests to make it more robust to failure, you should probably focus your effort in rewriting the core first to make it more robust as the problem is probably in the code and not in the functionality.
- if you want your unit tests to have value for more time you should focus on black box testing, test functions and methods based on their contracts and not their implementations this will make the test more valuable as long as the interface doesn't change.
- many things related to unit testing and many errors that get through are errors of assumption