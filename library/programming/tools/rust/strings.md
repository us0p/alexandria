strings are implemented as a collection of bytes, plus some methods to provide useful functionality when those bytes are interpreted as text.
## What is a String?
Rust has only one string type in the core language, which is the string slice `str` that is usually seen in its borrowed form `&str`.

The `String` type, is a growable, mutable, owned, `UTF-8` encoded string type.

When Rustaceans refer to "strings" in Rust, they might be referring to either the `String` or the string slice `&str` types, not just one of those. Both `Strin` and string slices are `UTF-8` encoded.
## Creating a new String
Many of the same operations available with `Vect<T>` are available with `String` because it's actually implemented as a wrapper around a vector of bytes with some extra guarantees, restrictions, and capabilities.
```rust
let mut s = String::new(); // empty string that can be loaded data into.

let data = "intiial contents"; // Strings literal implements the Display trait.

let s = data.to_string(); // Display.to_string() converts to a String.

let s = String::from("initial contents"); // same as Display.to_string()
```
## Updating a String
You can use the `+` operator or the `format!` macro to concatenate `String` values.
```rust
let mut s = String::from("foo");
s.push_str("bar"); // accepts a string slice, don't take ownership. 
// s == "foobar"

s.push('l'); // accepts a single character
// s == "foobarl"

let s1 = String::from("Hello, ");
let s2 = String::from("world!");
let s3 = s1 + &s2; // note s1 has been moved here and can no longer be used
// s3 == "Hello, world!"
```
When we use the `+` operator it calls the `add` method under the hood, whose signature looks something like this:
```rust
fn add(self, s: &str) -> String { /*...*/ }
```

Note that to call this function we need to use a `&str` as the `s` parameter. That's why we use `&s2` in `s3`.

Also note that we can only add a `&str` to a `String`, we can't add two `String` values together. The reason we're able to use `&s2` in the call to `add` is that the compiler can *coerce* the `&String` to a `&str`.

Finally, we can't use `s1` after our call to `add` because as we can see in the signature that `add` takes ownership of `self`.

Although `let s3 = s1 + &s2` looks like is copying both strings and creating a new one, this statement actually takes ownership of `s1`, appends a copy of the contents of `s2`, and then returns ownership of the result. This implementation is more efficient than copying.
```rust
let s1 = String::from("tic");
let s2 = String::from("tac");
let s3 = String::from("toe");

let s = s1 + '-' + &s2 + '-' + &s3; // "tic-tac-toe"
let s = format!("{s1}-{s2}-{s3}"); // "tic-tac-toe", s is a String 
```

The code generated by the `format!` macro uses references so that this call doesn't take ownership of any of its parameters.
## Indexing into String
Rust doesn't support string indexing because of the way strings are stored into memory. Unicode characters might fill more than one single index of the underlying [`Vector<u8>`](vectors.md)

A index into the string's bytes will not always correlate to a valid Unicode scalar value.

To avoid returning an unexpected value and causing bugs that might not be discovered immediately, Rust doesn't compile that kind of code and prevents misunderstandings early in the development process.
## Bytes, Scalar Values and Grapheme Clusters
Grapheme clusters are the closest thing to what we would call letters.
```rust
// The following examples represent the three different ways that rust can represent the Hindi word "नमस्ते".

// stored as a vector of `u8` values
let s = vec!([224, 164, 168, 224, 164, 174, 224, 164, 184, 224, 165, 141, 224, 164, 164, 224, 165, 135])

// stored as unicode scalar values
let s = vec!(['न', 'म', 'स', '्', 'त', 'े'])

// note that the fourth and sixth are not letters.
// they're diacritics that don't make sense on their own.

// stored as grapheme cluster of the four letters that make up the Hindi word:
let s = vec!(["न", "म", "स्", "ते"]);
```

A final reason Rust doesn’t allow us to index into a `String` to get a character is that indexing operations are expected to always take constant time (O(1)). But it isn’t possible to guarantee that performance with a `String`, because Rust would have to walk through the contents from the beginning to the index to determine how many valid characters there were.
## Slicing Strings
If you really need to use indices to create strings slices, you can use `[]` with a range to create a string slice containing particular bytes:
```rust
let hello = "Здравствуйте"; // Each character in this representation has 2 bytes.

let s = &hello[0..4]; // s is a &str that contain the string's first four bytes.
// s = "Зд"
```

If you try to slice only part of a character's bytes with something like `&hello[0..1]`, Rust would panic at runtime.

The best way to operate on pieces of strings is to be explicit about whether you want characters or bytes.
```rust
// for individual Unicode scalar values.
// this methods separates out and returns two values of type 'char'.
for c in "Зд".chars() {
	println!("{c}");
}

// for individual raw byte
for b in "Зд".bytes() {
	println!("{b}");
}
```
