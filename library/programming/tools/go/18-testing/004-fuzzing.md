# Fuzzing
Fuzzing is a testing technique where a function is called with randomly 
generated inputs to find bugs not anticipated by unit tests.  

```go
func FuzzXxx(*testing.F)
```

A fuzz test maintains a seed corpus, or a set of inputs which are run by 
default, and can seed input generation.  

!["Fuzz test example"](https://go.dev/security/fuzz/example-dark.png)

Seed inputs may be registered by callind `(*testing.F).Add` or by storing 
files in the directory `testdata/fuzz/<Name>` (where `<Name>` is the name 
of the fuzz test) within the package containing the fuzz test.  
Seed inputs are optional, but the fuzzing engine may find bugs more 
efficiently when provided with a set of small seed inputs with good code 
coverage.  

The function passed to `(*F).Fuzz` within the fuzz test is considered the 
fuzz target. A fuzz target must accept a `*T` parameter, followed by one or
more parameters for random inputs. The types of arguments passed to 
`(*F).Add` must be identical to the types of these parameters. The fuzz 
target may signal that it found a problem the same way tests do: by 
calling `T.Fail` (or any method that calls it like `T.Error` or `T.Fatal`)
or by panicking.  

When fuzzing is enabled (by setting the `-fuzz` flag to a regular 
expression that matches a specific fuzz test), the fuzz target is called 
with arguments generated by repeatedly making random changes to the seed 
inputs.  

On supported platforms, `go test` compiles the test executable with
fuzzing coverage instrumentation. The fuzzing engine uses that 
instrumentation to find and cache inputs that expand coverage, increasing 
the likelihood of finding bugs. If the fuzz target fails for a given input,
the fuzzing engine writes the inputs that caused the failure to a file in 
the directory `testdata/fuzz/<Name>` within the package directory. This 
file later serves as a seed input. If the file can't be written at that 
location, the fuzzing engine writes the file to the fuzz cache directory 
within the build cache instead.  
By default, all other tests in that package will run before fuzzing begins.
This is to ensure that fuzzing won’t report any issues that would already 
be caught by an existing test.  
While fuzzing is in progress, the fuzzing engine generates new inputs and 
runs them against the provided fuzz target. By default, it continues to run
until a failing input is found, or the user cancels the process 
(e.g. with Ctrl^C).  
  
The output looks something like this:

```plaintext
go test -fuzz FuzzFoo
fuzz: elapsed: 0s, gathering baseline coverage: 0/192 completed
fuzz: elapsed: 0s, gathering baseline coverage: 192/192 completed, now fuzzing with 8 workers
fuzz: elapsed: 3s, execs: 325017 (108336/sec), new interesting: 11 (total: 202)
fuzz: elapsed: 6s, execs: 680218 (118402/sec), new interesting: 12 (total: 203)
fuzz: elapsed: 9s, execs: 1039901 (119895/sec), new interesting: 19 (total: 210)
fuzz: elapsed: 12s, execs: 1386684 (115594/sec), new interesting: 21 (total: 212)
PASS
ok      foo 12.692s
```

- The first lines indicate that the “baseline coverage” is gathered before
  fuzzing begins.
- To gather baseline coverage, the fuzzing engine executes both the seed 
  corpus and the generated corpus, to ensure that no errors occurred and to
  understand the code coverage the existing corpus already provides.
- The lines following provide insight into the active fuzzing execution:
  - **elapsed**: the amount of time that has elapsed since the process 
    began.
  - **execs**: the total number of inputs that have been run against the 
    fuzz target (with an average execs/sec since the last log line).
  - **new interesting**: the total number of `interesting` inputs that have
    been added to the generated corpus during this fuzzing execution (with 
    the total size of the entire corpus).
  
For an input to be `interesting`, it must expand the code coverage beyond 
what the existing generated corpus can reach. It’s typical for the number 
of new interesting inputs to grow quickly at the start and eventually slow
down, with occasional bursts as new branches are discovered.  

Some options to run with fuzzing:
- **fuzztime**: the total time or number of iterations that the fuzz target
  will be executed before exiting, default indefinitely.
- **fuzzminimizetime**: the time or number of iterations that the fuzz 
  target will be executed during each minimization attempt, default 
  `60sec`. You can completely disable minimization by setting 
  `-fuzzminimizetime 0` when fuzzing.
- **parallel**: the number of fuzzing processes running at once, default 
  `$GOMAXPROCS`.

## Corpus file format
Corpus files are encoded in a special format.

```plaintext
go test fuzz v1
[]byte("hello\\xbd\\xb2=\\xbc ⌘")
int64(572293)
```

- The first line is used to inform the fuzzing engine of the file’s 
  encoding version.
- Each of the lines following are the values that make up the corpus entry,
  and can be copied directly into Go code if desired.
- In the example above, we have a `[]byte` followed by an `int64`. These 
  types must match the fuzzing arguments exactly, in that order. 
  A fuzz target for those types would look like this:  
  `f.Fuzz(func(*testing.T, []byte, int64) {...})`

The `file2fuzz` tool at can be used to convert these binary files to corpus 
files encoded for `[]byte`.  
  
When fuzzing is disabled, the fuzz target is called with the seed inputs 
registered with `F.Add` and seed inputs from `testdata/fuzz/<Name>`. In 
this mode, the fuzz test acts much like a regular test, with subtests 
started with `F.Fuzz` instead of `T.Run`.  

There must be exactly one fuzz target per fuzz test.
All `seed corpus` entries must have types which are identical to the 
fuzzing arguments, in the same order. This is true for calls to 
`(*testing.F).Add` and any corpus files in the testdata/fuzz directory of 
the fuzz test.  
The fuzzing arguments can only be of the following types:
- string, []byte
- int, int8, int16, int32/rune, int64
- uint, uint8/byte, uint16, uint32, uint64
- float32, float64
- bool
